---
name: 游戏功能开发文档生成器
description: 从用户提供的游戏功能需求文档（txt/md/doc/xlsx/脑图）生成专业的游戏功能开发文档，包含详细规则、数值配置、系统依赖和配置表设计
---

# 游戏功能开发文档生成器

## 概述

本 skill 用于指导 AI 助手**从用户提供的游戏功能需求文档生成专业的游戏功能开发文档**。

### 核心功能

将简要的游戏功能需求（txt/md/doc/xlsx/脑图）转化为详细的、可供开发人员直接实现的策划设计文档。

### 使用场景

当用户提到以下关键词或操作时，应使用此 skill：
- "游戏策划案"
- "游戏策划案生成"
- "需求转游戏策划案"
- "生成功能设计文档"
- 上传需求文档（txt/md/doc/xlsx）
- 上传游戏功能脑图

### 输入格式

支持以下格式的需求文档：
- **Markdown文件** (.md) - 包含核心玩法、主要规则、关键数值
- **Word文档** (.doc/.docx) - 简要的功能描述
- **Excel表格** (.xlsx) - 数据、规则、配置表
- **纯文本** (.txt) - 自然语言描述
- **思维导图/脑图** - 功能模块和规则的结构化呈现

### 输出结果

生成的**游戏功能开发文档**包含：
- 详细的功能规则说明（开启条件、运行规则、结束规则、特殊处理）
- 完整的数值配置（硬编码参数和可配置参数）
- 明确的系统依赖和接口需求
- 规范的配置表设计（复用已有表/增加字段/新建表）

### 核心目标

**让客户端和服务器程序员能清晰理解功能如何运作，并根据文档直接实现功能。**

### 设计原则

1. **清晰性优先** - 规则描述清晰明确，无歧义
2. **详细完整** - 包含所有开发所需信息，无遗漏
3. **可落地性** - 开发人员能直接根据文档编码实现
4. **灵活适配** - 根据功能特点调整章节内容，非死板套用模板
5. **项目一致** - 与现有文档保持术语、风格、配置表的统一性

### skill的作用

- � **需求理解** - 分析用户提供的简要需求文档
- � **智能扩展** - AI基于游戏设计经验补充细节和边界情况
- 🎯 **规范输出** - 生成符合项目规范的专业文档
- ✅ **质量保证** - 通过10项检查清单确保文档质量

**重要**：参考文档中的章节结构不是强制标准，可根据实际功能灵活调整。关键是确保文档**清晰、详细、可实现**。

## 使用方法

### 方式一：AI辅助从简要描述生成详细文档（推荐）

这是本skill的核心使用方式。适合快速将简要玩法构思扩展为完整的可开发文档。

#### 步骤0：项目文档分析（重要）⚠️

在开始生成文档之前，AI助手（你）**必须**执行以下步骤：

**1. 搜索工作区项目文档** ⚠️ **先询问用户**
   - **询问用户**："项目文档主要存放在哪个目录？"（获取准确的搜索路径）
   - 使用`find_by_name`工具搜索工作区内的所有功能文档
   - 支持的文档格式：`.md`（Markdown）、`.docx`（Word）、`.xlsx`（Excel）
   - **重要**：必须排除skill相关目录（详见下方"搜索路径和过滤规则"）
   
   **读取不同格式文档的方法**：
   - **Markdown文件(.md)**：使用`view_file`工具直接读取
   - **Word文档(.docx)**：使用`run_command`工具调用`scripts/read_docx.py`脚本
     ```python
     run_command(
         CommandLine='python "scripts/read_docx.py" "文档路径.docx" markdown',
         Cwd='g:/zmd works/skills/game_design_doc/scripts',
         SafeToAutoRun=True,
         WaitMsBeforeAsync=3000
     )
     ```
   - **Excel文件(.xlsx)**：使用`run_command`工具调用`scripts/read_xlsx.py`脚本
     ```python
     run_command(
         CommandLine='python "scripts/read_xlsx.py" "文件路径.xlsx" markdown',
         Cwd='g:/zmd works/skills/game_design_doc/scripts',
         SafeToAutoRun=True,
         WaitMsBeforeAsync=3000
     )
     ```
   
**2. 判断是否存在项目文档**
   - **若存在项目文档**：逐个阅读所有找到的功能文档
     - 了解项目的整体架构和功能体系
     - 理解现有功能的设计模式和风格
     - 识别已有的系统和模块（如资源系统、VIP系统、背包系统等）
     - 提取通用的规则模式和数值范围
     - 学习配置表的命名规范和字段设计模式
     - **分析现有文档的规则描述写法和表述方式** ⚠️ **重要**
       - 观察如何描述条件判断（如开启条件、参与条件）
       - 学习如何描述流程和循环规则
       - 注意特殊处理和异常情况的描述方式
       - 理解表格的使用场景和格式
       - 掌握数值计算公式的表述方法
       - 识别文档的详细程度和深度
   - **若不存在项目文档**：按照默认模板和最佳实践生成文档

**3. 建立项目上下文** ⚠️ **关键步骤**
   - **记录项目中已有的系统功能清单**：列出所有已实现的系统和模块
   - **记录常用的数值范围和设计惯例**：提取数值设计模式
   - **记录所有已有配置表**：建立配置表清单，包括表名、用途、字段列表 ⚠️ **重要**
   - **提取标准术语表**：识别项目中的核心术语和统一表述方式 ⚠️ **重要**
     - 功能模块名称（如【背包系统】、【VIP系统】、【任务系统】）
     - 游戏元素名称（如【金币】、【钻石】、【体力】、【经验值】）
     - 状态术语（如【已解锁】、【进行中】、【已完成】）
     - 操作术语（如【领取】、【购买】、【使用】、【升级】）
   - **总结项目的规则描述风格** ⚠️ **关键**
     - 文档的详细程度和深度（简洁型 vs 详尽型）
     - 常用的规则描述模式（表格为主 vs 文字为主）
     - 条件判断的表述方式（表格式 vs 列表式）
     - 流程描述的风格（步骤式 vs 叙述式）
     - 公式和计算的表达方式
     - 特殊处理的组织方式

**为什么这一步很重要**：
- ✅ 确保新功能与现有功能风格一致
- ✅ 避免重复设计已有的系统
- ✅ 复用项目中的通用规则和模式
- ✅ 保持配置表设计的一致性
- ✅ 使用项目统一的术语体系
- ✅ 学习项目的规则描述风格

**搜索路径和过滤规则** ⚠️ **重要配置**：

**1. 询问用户项目文档路径**
- 在开始搜索前，询问用户："项目文档主要存放在哪个目录？"
- 如果用户指定了路径，使用该路径作为 SearchDirectory
- 如果用户未指定，使用默认搜索路径

**2. 默认搜索路径**
- SearchDirectory：当前工作区根目录
- 例如：如果工作区是 `g:/zmd works/skills`，则搜索 `g:/zmd works/skills`

**3. 必须排除的目录** ⚠️ **关键**
使用 `find_by_name` 工具的 Excludes 参数排除以下目录：
- `**/skills/**` - 排除所有skill相关目录（避免搜索到skill示例文档）
- `**/game_design_doc/**` - 排除本skill自身目录
- `**/examples/**` - 排除示例文件目录
- `**/scripts/**` - 排除脚本工具目录
- `**/node_modules/**` - 排除依赖包
- `**/.git/**` - 排除版本控制
- `**/dist/**` - 排除构建输出
- `**/build/**` - 排除构建输出
- `**/temp/**` 或 `**/tmp/**` - 排除临时文件

**4. 搜索示例**：

询问用户后执行搜索：
```
用户回答示例1："项目文档在 g:/project/docs 目录"
→ SearchDirectory: g:/project/docs
→ Excludes: ["**/examples/**", "**/scripts/**", "**/node_modules/**", "**/.git/**"]

用户回答示例2："就用默认路径吧" 或 未明确指定
→ SearchDirectory: [当前工作区根目录]
→ Excludes: ["**/skills/**", "**/game_design_doc/**", "**/examples/**", "**/scripts/**", 
            "**/node_modules/**", "**/.git/**", "**/dist/**", "**/build/**"]
```

**5. 验证搜索结果**
- 搜索完成后，检查找到的文档列表
- 如果列表中包含skill示例文件（如 example_system.md），说明过滤失败，需要调整
- 向用户确认："找到了 X 个文档，是否需要排除某些目录？"

#### 步骤1：准备简要描述

用户提供功能的简要描述，可以是：
- **Markdown文件** - 包含核心玩法、主要规则、关键数值
- **文字描述** - 直接用自然语言描述功能
- **思维导图** - 功能模块和规则的结构化呈现

**简要描述应包含**：

**功能名称**：明确的功能名称

**核心玩法**：1-3段话描述核心玩法流程和玩家操作

**主要规则**：列表形式罗列关键规则
- 规则1
- 规则2
- 规则3...

**关键数值**（可选）：列出重要参数
- 参数1: 具体数值
- 参数2: 具体数值

**特殊说明**（可选）：任何特殊要求或注意事项

#### 步骤2：AI分析和扩展

AI助手（你）应该：

1. **理解核心玩法** - 提取功能的本质和目标
   - 明确功能的输入和输出
   - 识别核心循环和玩家决策点
   - 确定功能的价值定位

2. **推导完整规则** - 基于游戏设计经验补充细节
   - **开启条件**：玩家需要满足什么才能使用该功能
     - 等级条件、前置任务、资源条件等
     - 时间条件（如开服天数）
   - **参与条件**：每次使用的门槛和限制
     - 消耗条件、次数限制、冷却时间等
   - **运行规则**：功能如何循环、刷新、结束
     - 循环周期（日、周、月、不循环）
     - 刷新时间点和规则
     - 结束条件和结算逻辑
   - **边界条件**：各种临界情况的处理
     - 数值上限/下限、容量上限
     - 并发操作的处理
   - **异常处理**：意外情况的处理方式
     - 网络断线、资源不足、背包满等
     - 数据回滚和补偿机制

3. **规则细节完整性检查** ⚠️ **关键要求**
   - ✅ 每条规则必须有明确的触发条件和执行结果
   - ✅ 所有提到的参数必须说明具体数值或取值范围
   - ✅ **必须明确标注参数是否可配置**
     - 硬编码参数：在规则中直接给出固定值，如"免费加速时间≤5分钟"
     - 可配置参数：需在配置表中设计，如"建造时长（见配置表）"
   - ✅ 所有涉及计算的地方必须提供公式和示例
   - ✅ 所有特殊情况必须有明确的处理方式

4. **确定系统依赖** - 分析需要哪些其他系统支持
   - 列出所有依赖的系统模块（如背包系统、任务系统等）
   - 说明需要的接口功能和数据交互
   - 识别潜在的循环依赖问题

5. **完善数值配置** - 扩展为完整的数值表格
   - 所有数值参数必须有明确的取值
   - 使用表格清晰呈现数值关系
   - 说明数值的成长曲线和平衡考虑
   - **区分哪些是示例数值，哪些是最终数值**

6. **设计配置表结构** - 定义数据库表结构 ⚠️ **严格要求**
   
   **配置表复用原则**（最重要）：
   - **优先复用已有配置表** - 检查步骤0中记录的配置表清单
   - **禁止重复创建表** - 如果已有表可以满足需求，只需在已有表中增加数据或字段
   - **只有在没有合适的已有表时，才能创建新表**
   
   **具体操作要求**：
   - 如需在已有表中**增加数据**：说明在哪张表的哪个字段增加什么数据
   - 如需在已有表中**增加字段**：说明在哪张表增加什么字段、类型、说明
   - 如需**创建新表**：必须说明为什么已有表无法满足需求
   
   **基础设计要求**：
   - **配置表字段必须覆盖规则中提到的所有可配置参数**
   - 字段命名遵循项目规范（参考步骤0中的项目文档）
   - 字段类型和说明必须完整
   - 考虑扩展性和维护性
   
7. **术语统一性检查** ⚠️ **必须执行**
   - 检查文档中的术语是否与项目已有术语一致
   - 相同的功能和模块必须使用统一的术语表述
   - 所有核心术语必须使用【】或""符号标注
   - 示例：
     - 统一使用【背包系统】而不是背包功能、道具系统等
     - 统一使用【金币】而不是游戏币、货币等
     - 统一使用【领取】而不是获得、拿取等

8. **配置表与规则的一致性校验** ⚠️ **必须执行**
   - 在完成文档后，检查规则说明和配置表设计的一致性：
     - 规则中提到的每个"可配置参数"是否都在配置表中有对应字段
     - 配置表中的字段是否都在规则中被引用和说明
     - 字段的数据类型是否匹配规则描述
     - **是否复用了已有配置表，而不是重复创建新表** ⚠️ **关键检查**
   - 如发现不一致，必须修正

#### 步骤3：组织文档结构

根据功能特点选择合适的章节结构。**不必死板套用标准模板**，而是根据功能复杂度和类型灵活调整。

**最小必要章节**（简单功能）：
- 一、功能概述
- 二、规则说明
- 三、数值需求

**完整章节**（复杂功能）：
- 一、设计目的
- 二、功能概述
- 三、规则说明（多个子章节）
- 四、策划需求（数值、系统、配置表）

**关键原则**：确保开发人员能清晰理解功能运作方式。

#### 步骤4：生成文档并执行质量检查

**默认格式：Markdown文件**

生成的文档默认为markdown格式（.md），便于：
- 版本控制（Git友好）
- 跨平台使用
- 程序员直接查看和编辑
- 团队协作和评审

**备选格式：Word文档**

如果需要Word格式，可以使用生成脚本：
- 进入scripts目录
- 执行generate_doc.py脚本
- 参数：--name "功能名称" --type "类型"

或者将markdown内容复制到Word，应用相应的样式。

---

**📋 文档质量检查清单** ⚠️ **生成文档后必须执行**

在提交文档给用户之前，AI助手必须对生成的文档进行以下检查：

**1. 规则完整性检查**
- [ ] 是否包含开启条件、参与条件、循环规则、结束规则？
- [ ] 是否覆盖所有正常流程和异常情况？
- [ ] 是否有明确的边界条件处理（如上限、下限、满额等）？
- [ ] 特殊处理章节是否详细说明了各种异常场景？

**2. 规则细节检查**
- [ ] 每条规则是否有明确的触发条件和执行结果？
- [ ] 所有提到的参数是否都有具体数值或取值范围？
- [ ] 涉及计算的地方是否提供了公式和计算示例？
- [ ] 规则描述是否清晰无歧义？

**3. 参数可配置性标注检查** ⚠️ **重点检查**
- [ ] 规则中提到的所有参数是否明确标注了是"硬编码"还是"可配置"？
- [ ] 可配置参数是否注明"见配置表"或"通过配置表设置"？
- [ ] 硬编码参数是否直接给出了确定的数值？

**4. 配置表一致性检查** ⚠️ **严格要求**
- [ ] 规则中标注为"可配置"的参数，是否在配置表设计中有对应字段？
- [ ] 配置表中的每个字段，是否在规则说明中被引用和解释？
- [ ] 字段的数据类型（int/string/json等）是否匹配规则描述？
- [ ] 配置表的字段命名是否符合项目规范？

**5. 数值需求检查**
- [ ] 是否列出了所有需要配置的数值参数？
- [ ] 数值说明是否包含参数名称、取值、说明三要素？
- [ ] 是否区分了示例数值和最终确定数值？

**6. 系统依赖检查**
- [ ] 是否列出了所有依赖的系统模块？
- [ ] 是否说明了需要的接口功能？
- [ ] 依赖的系统是否在项目中已经存在（参考步骤0的分析结果）？

**7. 格式规范检查**
- [ ] 标题层级是否正确（H1/H2/H3）？
- [ ] 表格是否有清晰的表头？
- [ ] 列表是否有合理的层级和缩进？
- [ ] 是否善用了表格来呈现结构化信息？

**8. 术语统一性检查** ⚠️ **关键检查**
- [ ] 文档中的功能和模块名称是否与项目已有术语一致？
- [ ] 相同的功能是否使用了统一的表述方式？
- [ ] 所有核心术语是否使用【】或""符号进行了标注？
- [ ] 是否避免了同一概念的多种说法（如金币/游戏币/货币）？

**9. 配置表复用检查** ⚠️ **严格要求**
- [ ] 是否检查了项目已有的配置表清单？
- [ ] 如果已有表可以满足需求，是否复用而不是创建新表？
- [ ] 如果需要增加数据或字段，是否明确说明在哪张表中操作？
- [ ] 如果创建新表，是否说明了为什么已有表无法满足需求？
- [ ] 是否使用【新建】【增加数据】【增加字段】等标注明确了配置表操作类型？

**10. 禁止代码/伪代码检查** ⚠️ **关键检查**
- [ ] 文档中是否完全没有代码块？
- [ ] 规则描述中是否没有if/else/for/while等编程语句？
- [ ] 是否没有函数调用形式（如"function()"）？
- [ ] 所有逻辑和规则是否都用自然语言、表格或列表描述？
- [ ] 数值计算是否使用数学公式而非代码语法？

**如果任何一项检查不通过，必须修正后再提交给用户。**

---

### 方式二：使用脚本生成空白框架（传统方式）

适合已经有清晰思路，只需要一个结构框架的情况。

## 标准文档结构

### 文档结构模板

以下是推荐的文档结构，**不必完全遵循**，可根据功能特点调整。

**标题 + 文档信息（必须）**
- 文档版本
- 创建日期
- 最后更新
- 需求来源
- 功能类型
- 目标用户

**一、设计目的**
- 1.1 功能定位
- 1.2 期望体验

**二、功能概述**
- 2.1 背景概述
- 2.2 功能简介
- 2.3 结构划分

**三、规则说明**
- 3.1 功能状态机（可选）
- 3.2 开启条件
- 3.3 参与条件
- 3.4 循环方式/运行规则
- 3.5 结束规则
- 3.6 特殊处理
- 3.7 红点提示规则（可选）
- 3.8 [其他功能特定规则]
- **开发注意事项**：在相关规则章节末尾添加实现注意事项

**四、策划需求**
- 4.1 数值需求
- 4.2 系统需求
- 4.3 配置表需求

### 标题 + 文档信息

**目的**：提供文档的基本信息和版本管理。

**书写位置**：文档最开头，紧跟在标题之后。

**内容示例**：

```markdown
# 功能名称 功能设计文档

## 文档信息

- **文档版本**：v1.0
- **创建日期**：2026-01-29
- **最后更新**：2026-01-29
- **需求来源**：《XXX需求文档》
- **功能类型**：核心系统/活动玩法/辅助功能
- **目标用户**：客户端和服务器开发人员
```

---

### 一、设计目的

**目的**：说明为什么要做这个功能，期望达到什么效果。

#### 1.1 功能定位
- 描述功能在游戏中的定位和作用
- 说明功能解决的核心问题或满足的玩家需求
- 示例：
  > 本功能为游戏核心资源获取系统之一，提供稳定的资源产出途径，增强玩家养成体验。

#### 1.2 期望体验
- 描述玩家使用该功能时的预期体验
- 说明功能带来的价值和乐趣
- 示例：
  > 玩家通过简单操作即可获得资源奖励，体验成长的满足感；通过策略选择优化收益，体验决策的乐趣。

---

### 二、功能概述

**目的**：全面介绍功能的基本信息和整体框架。

#### 2.1 背景概述
- 功能的背景故事或世界观设定（如适用）
- 功能在游戏整体设计中的位置
- 示例：
  > 神秘的神石散落在王国各处，蕴含强大的魔法能量，玩家可以搜集神石获得属性加成。

#### 2.2 功能简介
- **核心玩法**：用1-3段话描述功能的核心玩法流程
- **主要特点**：列出功能的3-5个关键特性
- **玩家操作**：简述玩家的主要交互行为
- 示例：
  > 玩家可以在城堡中建造和升级各类建筑。每个建筑都有特定的功能和产出。建筑升级需要消耗资源和时间，玩家可以使用道具加速建造过程。

#### 2.3 结构划分
- 使用**列表**或**思维导图**方式展示功能的结构组成
- 包含功能模块、子系统、主要流程等
- 示例（列表形式）：

  活动中心
  ├── 活动专区
  │   ├── 日常活动
  │   ├── 限时活动
  │   └── 节日活动
  ├── 特惠福利
  │   ├── 首充奖励
  │   └── 累充奖励
  └── 活动公告

---
### 三、规则说明

**目的**：详细描述功能的运行规则和逻辑，这是文档的核心部分。

⚠️ **重要原则：禁止使用代码和伪代码**

在描述客户端和服务器的规则时，**严禁使用任何形式的代码或伪代码**。必须使用纯文本、表格、列表来描述规则。

**错误示例**（禁止使用）：
- "if (player.level >= 5) then unlock()"
- "for each building in buildings: calculate_output()"
- "reward = base_value * (1 + level * 0.5)"
- 任何类似编程语言的语法结构

**正确示例**（应该使用）：
- "当玩家等级达到5级时，解锁该功能"
- "遍历所有建筑，计算每个建筑的产出值"
- "奖励计算公式：奖励 = 基础值 × (1 + 等级 × 0.5)"
- 使用表格展示条件判断和分支逻辑

**描述规则的推荐方式**：
1. **使用表格**：展示条件、触发机制、执行结果
2. **使用列表**：逐条描述规则步骤
3. **使用自然语言**：清晰明确地说明逻辑关系
4. **使用数学公式**：对于数值计算，使用数学符号而非代码语法

⚠️ **术语标注要求**：所有核心功能、游戏元素、操作术语必须使用【】符号标注，保持与项目已有术语一致。
**注意**：⚠️ **以上提示仅供AI参考，不要将这些提示文字写入输出的文档中**

#### 3.1 功能状态机（可选）
- 使用**表格**描述功能的各种状态及转换条件
- 表格格式示例：

| 状态 | 说明 | 进入条件 | 退出条件 |
|------|------|----------|----------|
| 未开启 | 功能尚未解锁 | 游戏初始状态 | 满足开启条件 |
| 进行中 | 功能正在运行 | 活动开始时间到达 | 活动结束或手动退出 |
| 已结束 | 功能已完成 | 完成所有任务 | 重置或刷新 |

#### 3.2 开启条件
- 列出功能解锁的所有条件
- 使用**表格**或**列表**清晰呈现
- 表格格式示例：

| 条件类型 | 具体要求 | 说明 |
|----------|----------|------|
| 玩家等级 | 主堡等级≥5 | 玩家需先升级主堡 |
| 前置功能 | 完成新手引导 | 确保玩家理解基础玩法 |
| 时间限制 | 服务器开服后第3天 | 避免新手期功能过载 |

#### 3.3 参与条件
- 描述玩家进入功能或参与玩法的条件
- 与开启条件的区别：开启条件是功能解锁，参与条件是每次使用的门槛
- 示例：
  > 每日可参与3次，消耗10点体力。VIP等级≥3的玩家可额外获得2次机会。

#### 3.4 循环方式/运行规则
- 描述功能的循环机制（日常/周常/不循环等）
- 适合用**表格**说明不同循环类型
- 表格示例：

| 循环方式 | 循环规则 | 案例 |
|----------|----------|------|
| 日循环 | 每日0点刷新 | 每日任务 |
| 周循环 | 每周一0点刷新 | 周常活动 |
| 固定时间循环 | 每周三、周日开启 | 限时副本 |
| 不循环 | 一次性功能 | 新手奖励 |

#### 3.5 结束规则
- 描述功能结束的条件和方式
- 说明结束后的处理逻辑（奖励发放、数据清除等）
- 表格示例：

| 结束条件 | 结束规则 | 后续处理 |
|----------|----------|----------|
| 时间到期 | 活动结束时间到达 | 自动结算奖励并发送邮件 |
| 任务完成 | 所有任务目标达成 | 弹出完成提示，领取奖励 |
| 手动退出 | 玩家主动关闭 | 保存当前进度 |

#### 3.6 特殊处理/特殊规则
- 列出所有特殊情况及其处理方式
- 包括异常场景、边界情况、容错机制等
- 表格示例：

| 特殊情况 | 处理方式 |
|----------|----------|
| 玩家在功能进行中等级下降 | 保持当前状态，直到本次结束后重新检查 |
| 网络断线 | 保存断线前进度，重连后可继续 |
| 资源不足以完成操作 | 弹出提示，引导玩家前往获取资源 |
| 背包已满无法领取奖励 | 奖励发送至邮件，保留7天 |

**开发注意事项** ⚠️ **重要**：

在每个相关规则章节末尾，添加该规则的实现注意事项。这些注意事项应该：
- 直接跟在相关规则后面，不要单独成章
- 使用"**开发注意事项**："作为标题
- 列举该规则实现时的关键点，如数据同步、性能优化、作弊防护、体验优化等

示例：
```
**开发注意事项**：
- **数据同步**：玩家的【基础属性】必须实时同步到服务器，避免数据丢失
- **性能优化**：每日计算可以在玩家登录时异步执行，避免阻塞主流程
```

#### 3.7 规则描述规范 ⚠️ **重要**

为确保文档清晰且易于理解，以下是规则描述的正确和错误示例对比：

**场景1：条件判断**
- ❌ 错误：`if (player.vip_level >= 3) { queue_count = 2 } else { queue_count = 1 }`
- ✅ 正确：使用表格描述

| VIP等级 | 建造队列数量 |
|---------|-------------|
| VIP0-2 | 1个 |
| VIP3及以上 | 2个 |

**场景2：循环遍历**
- ❌ 错误：`for (item in reward_list) { player.add_item(item.id, item.count) }`
- ✅ 正确：遍历奖励列表，将每个奖励道具添加到玩家背包，道具ID和数量从奖励配置中读取

**场景3：数值计算**
- ❌ 错误：`damage = base_atk * (1 + level * 0.1) * skill_bonus`
- ✅ 正确：伤害计算公式：伤害 = 基础攻击力 × (1 + 等级 × 0.1) × 技能加成系数

**场景4：多条件判断**
- ❌ 错误：
  ```
  if (time > start_time && time < end_time && player.level >= 10) {
      return true
  }
  ```
- ✅ 正确：功能开启需同时满足以下条件：
  - 当前时间在活动开始和结束时间之间
  - 玩家等级≥10级

**场景5：流程描述**
- ❌ 错误：`onClick() { check_condition(); deduct_resource(); give_reward(); }`
- ✅ 正确：玩家点击按钮后执行以下流程：
  1. 检查是否满足参与条件
  2. 扣除所需资源
  3. 发放奖励

**记住**：策划文档使用自然语言、表格、列表，**绝不使用代码或伪代码**。

#### 3.8 功能逻辑细节拆分方法 ⚠️ **重要**

**核心原则**：看似简单的功能，实际会有很多逻辑细节。必须分析和拆分这些细节并加以清晰描述。

##### 方法1：边界条件穷举

**数值边界**：明确使用数学符号
- ❌ 错误："当英雄数量很多时显示滚动条"
- ✅ 正确：
  - 当英雄数量 > 4时：滚动列表能够左右拖动，单屏显示4个完整英雄 + 第5个英雄的一半
  - 当英雄数量 ≤ 4时：滚动列表无法拖动，英雄居中排列显示

**状态边界**：明确每种状态的表现和交互
- ❌ 错误："达到上限的英雄不能选择"
- ✅ 正确：
  - 当英雄的"神石加成"属性达到上限时：
    - 图标与属性数据呈灰态
    - 英雄立绘呈灰态
    - 无法触发点击事件

**时间边界**：明确时间节点的判断条件
- ❌ 错误:"刷新时间到了就刷新神石"
- ✅ 正确：
  - 若玩家在刷新时间点前未通关神石所刷新的关卡，玩家在下一次神石刷新时间之前即使通关了该关卡，也无法显示已刷新的神石

##### 方法2：组合条件拆分

将复杂的组合条件拆分为清晰的条件A + 条件B → 结果

**示例：刷新时的玩家状态处理**

❌ 错误："到达刷新时间时更新神石"

✅ 正确：

**场景1：玩家处于RPG场景，到达神石刷新时间，场景神石出现**
- 条件1：玩家处于可刷新神石的RPG场景内
- 条件2：到达刷新时间
- 结果：神石即时出现，需要有渐隐的客户端表现效果

**场景2：玩家处于RPG场景，到达神石刷新时间，场景神石消失**
- 条件1：玩家处于已刷新神石的RPG场景内
- 条件2：视野内有神石存在
- 条件3：到达刷新时间
- 结果：神石即时刷新消失，需要有渐隐的客户端表现效果

**场景3：到达神石刷新时间，玩家开启神石详情界面**
- 条件1：玩家处于打开神石详情界面的状态下
- 条件2：到达刷新时间
- 结果：直接关闭神石详情界面，神石即时刷新消失

##### 方法3：多级规则描述

使用多级优先级链描述排序或选择逻辑。使用表格清晰呈现：

| 优先级 | 排序规则 | 说明 |
|--------|---------|------|
| 第一级 | 品质排序 | 已拥有的英雄按照当前英雄品质由高到低顺序依次排列 |
| 第二级 | 等级排序 | 同品质英雄下，按照英雄等级由高到低顺序依次排列 |
| 第三级 | ID排序 | 同品质同等级下，按照英雄ID顺序依次排列 |
| 兜底规则 | 状态排序 | 达到加成上限的英雄呈灰态，按照上述3条规则滞后排序 |

##### 方法4：默认状态和重置条件

明确功能的默认状态和重置时机

❌ 错误："提供'不再显示'选项"

✅ 正确：

| 规则类型 | 说明 |
|---------|------|
| 功能说明 | 勾选状态下进行下一步操作后，后续再次使用"选择英雄"功能时，不再显示该确认提示界面 |
| 功能规则 | 玩家选中"勾选中不再显示"功能后，在玩家后续游玩过程中，在需要选择英雄的流程中都隐藏该步骤。即：玩家只要选择英雄完毕后，不再弹出确认窗口界面，直接进行确认窗口中"确定"状态的结果判定 |
| 默认状态 | 【"不再显示"功能默认处于不勾选状态】 |
| 重置规则 | 玩家勾选"勾选中不再显示"功能后，可在设置界面内对此功能进行开关；当玩家关闭游戏进程或因服务器断线软重启后，重置此功能的设置状态 |

##### 方法5：表现与逻辑分离

明确区分逻辑变化和UI表现

| 逻辑 | 表现 |
|------|------|
| 神石消失 | 需要有渐隐的客户端表现效果 |
| 英雄达到属性上限 | 图标与数据呈灰态 |
| 属性加成值更新 | 以"当前值/上限值"的形式显示（如：3/30） |

##### 方法6：多级概率描述

当涉及随机或概率时，明确每一级的概率规则

❌ 错误："随机刷新神石"

✅ 正确：

**刷新位置**：
- 神石会在所有关卡地图中预配置的刷新点位置处随机刷新
- 刷新数量根据预设配置【配置】

**刷新内容**（三步骤）：
1. **第一步：读取神石组** - 根据刷新点配置读取可刷新的神石组内容
2. **第二步：按概率选择神石组** - 不同的神石组有着不同的概率（例如：+1神石组概率60%、+2神石组概率30%、+3神石组概率10%）
3. **第三步：组内等概率选择** - 确定刷新的神石组后，等概率刷新组内的一种神石

##### 自检清单

在描述功能逻辑时，问自己以下问题：

- [ ] **数值边界在哪里？** 是否明确了 >、<、≥、≤、= 的边界条件？
- [ ] **状态组合有哪些？** 玩家在A状态 + 触发B事件会发生什么？是否穷举了所有组合？
- [ ] **排序/优先级是什么？** 多个条件同时满足时，按什么顺序处理？是否有兜底规则？
- [ ] **默认状态是什么？** 功能首次使用时的状态？重置后的状态？
- [ ] **表现效果是什么？** 每个逻辑变化对应的UI表现是什么？是否有动画/过渡效果要求？
- [ ] **什么需要配置？** 哪些是硬编码参数？哪些需要策划后续调整？是否用【配置】标记？

**记住**：通过分析项目现有文档，学习其对功能逻辑细节的描述方式，然后应用到新功能设计中。

#### 3.9 红点提示规则（可选）
- 说明红点显示的触发条件和消失条件
- 表格示例：

| 提示位置 | 出现条件 | 消失条件 |
|----------|----------|----------|
| 功能入口按钮 | 有未领取奖励 | 领取所有奖励 |
| 任务列表 | 有可完成任务 | 查看任务详情 |
| 活动专区 | 有新活动开启 | 进入活动界面 |

#### 3.9.5 文档简洁性规则 ⚠️ **重要**

**核心原则**：保留逻辑清晰度和边界条件，但去除不必要的重复穷举。

##### 规则1：相同逻辑不全部列出

**问题场景**：当某个规则的计算逻辑在所有等级/层级中完全相同时

❌ **错误做法**：列出所有等级的详细表格
```markdown
| 等级 | 所需经验 | 说明 |
|------|---------|------|
| Lv.1 | 累计值≥0且<100 | 初始等级，累计值0-99时保持Lv.1 |
| Lv.2 | 累计值≥100且<200 | 累计值达到100时立即提升到Lv.2 |
| Lv.3 | 累计值≥200且<300 | 累计值达到200时立即提升到Lv.3 |
... (继续列出Lv.4到Lv.10，每行说明都类似)
```

✅ **正确做法**：规则说明 + 配置表引用 + 少量示例
```markdown
**等级提升规则**：

各等级所需的累计成长值阈值在配置表中定义，具体数值见配置表`level_config`的`exp_requirement`字段。

**判定逻辑**：
- 当累计值≥某等级阈值且<下一等级阈值时：保持该等级
- 当累计值达到下一等级阈值时：等级立即提升

**示例说明**：
| 等级 | 所需累计值 | 说明 |
|------|-----------|------|
| Lv.1 | 累计值≥0且<100 | 初始等级 |
| Lv.2 | 累计值≥100且<200 | 累计值达到100时立即提升到Lv.2 |
| Lv.5 | 累计值≥500且<800 | 累计值达到500时立即提升到Lv.5 |
| Lv.10 | 累计值≥3000 | 最高等级，之后继续累计但不再提升 |
```

**关键点**：
- ✅ 保留判定逻辑的边界条件（≥、<等符号）
- ✅ 提供几个有代表性的示例（首个、中间、最后）
- ✅ 引用配置表字段，便于开发查询完整数据
- ❌ 不要列出所有10个等级的相同说明

##### 规则2：合并相同结构的配置表

**问题场景**：多个配置项都遵循同样的计算公式，仅参数不同

❌ **错误做法**：分别列出多个独立表格
```markdown
**作坊升级消耗表**：
| 等级 | 消耗金币 |
|------|---------|
| 1→2级 | 100金币 |
| 2→3级 | 300金币 |
... (继续列出所有等级)

**任务奖励金币表**：
| 等级 | 奖励金币 |
|------|---------|
| 等级1 | 50金币 |
| 等级2 | 150金币 |
... (继续列出所有等级)

**任务奖励经验表**：
| 等级 | 奖励经验 |
|------|---------|
| 等级1 | 10点 |
| 等级2 | 20点 |
... (继续列出所有等级)
```

✅ **正确做法**：统一的公式配置表
```markdown
**数值配置公式**（详细数值见配置表）：

| 配置项 | 计算公式 | 示例 | 配置表字段 |
|-------|---------|------|----------|
| 作坊升级消耗 | 100×N×N金币（N为当前等级） | 1→2级：100金币；2→3级：300金币 | workshop_upgrade_cost |
| 任务奖励金币 | 50×N+50金币（N为任务等级） | 等级1：50金币；等级2：150金币 | task_reward_coin |
| 任务奖励经验 | 10×N点（N为任务等级） | 等级1：10点；等级2：20点 | task_reward_exp |
```

**关键点**：
- ✅ 汇总所有遵循公式的配置项到一个表格
- ✅ 明确计算公式和变量含义
- ✅ 提供1-2个计算示例验证公式正确性
- ❌ 不要为每个配置项单独列表

##### 规则3：简化重复的场景描述

**问题场景**：多个场景的处理逻辑可以概括为一个统一规则

❌ **错误做法**：逐一列举所有场景
```markdown
**场景1：恰好两个属性达到Lv.5**
- 条件：属性A≥Lv.5且属性B≥Lv.5，其他两个<Lv.5
- 判定：满足条件，触发解锁

**场景2：三个属性达到Lv.5**
- 条件：属性A≥Lv.5且属性B≥Lv.5且属性C≥Lv.5
- 判定：满足条件，触发解锁

**场景3：四个属性达到Lv.5**
- 条件：四个属性全部≥Lv.5
- 判定：满足条件，触发解锁

**场景4：只有一个属性达到Lv.5**
- 条件：仅一个属性≥Lv.5，其他<Lv.5
- 判定：不满足条件，保持当前阶段
```

✅ **正确做法**：统一规则 + 关键示例
```markdown
**判定规则**：统计属性中≥Lv.5的数量
- **当数量≥2时**：触发解锁
- **当数量<2时**：保持当前阶段，显示进度"{当前数量}/2个属性已达标"

**示例**：
- ✅ 满足条件：属性A=Lv.5、属性B=Lv.6 → 触发解锁
- ✅ 超过要求：属性A=Lv.5、属性B=Lv.5、属性C=Lv.7 → 触发解锁
- ❌ 不满足：仅属性A=Lv.5 → 保持阶段，显示"1/2个属性已达标"
```

**关键点**：
- ✅ 提炼统一的判定规则
- ✅ 提供正反两面的示例（满足/不满足）
- ✅ 说明边界情况的处理方式
- ❌ 不要穷举所有可能的属性组合

##### 规则4：简化相同数据的初始值表

**问题场景**：多个字段的初始值完全相同

❌ **错误做法**：逐行列出每个字段
```markdown
| 属性名称 | 初始值 | 初始等级 |
|---------|-------|---------|
| 想象力 | 0点 | Lv.1 |
| 感性 | 0点 | Lv.1 |
| 依赖 | 0点 | Lv.1 |
| 稳重 | 0点 | Lv.1 |
```

✅ **正确做法**：合并描述相同数据
```markdown
所有四个基础属性（想象力、感性、依赖、稳重）的初始值相同：
- 初始累计值：0点
- 初始等级：Lv.1
```

##### 自检清单

生成文档后，检查以下项目：

- [ ] **重复表格检查**：是否存在10行以上的表格，但每行逻辑完全相同？→ 改为规则+示例
- [ ] **公式提取检查**：是否有3个以上的配置表遵循相同的计算公式？→ 合并为公式配置表
- [ ] **场景穷举检查**：是否列出了5个以上的场景，但判定规则统一？→ 改为统一规则+关键示例
- [ ] **初始值检查**：是否列出了多行相同的初始值？→ 合并描述
- [ ] **配置表引用**：是否明确引用了配置表字段？→ 便于开发查询完整数据

**记住**：简洁不等于省略重要信息。边界条件、判定逻辑、特殊处理仍需完整描述，只是避免无意义的重复穷举。

#### 3.11 [其他功能特定规则]
- 根据具体功能添加其他必要的规则说明
- 常见的额外规则类型：
  - **建筑功能**：升级规则、加速规则、建造队列规则
  - **战斗功能**：伤害计算、技能释放、胜负判定
  - **养成功能**：经验计算、突破规则、属性加成
  - **社交功能**：好友上限、互动规则、协作机制

**填写建议**：
- 善用**表格**来组织结构化信息
- 对于复杂规则，可以使用**公式**或**流程图描述**（文字描述流程）

---

### 四、界面流程（可选）

**目的**：提供功能的界面原型和交互说明，便于UI/UE设计和客户端开发。

**使用场景**：
- 当策划完成原型图绘制后，可将原型图和UE说明补充到此章节
- 此章节为**可选内容**，在文档初期生成时可以暂时省略
- 后期补充时，将原型图和交互说明添加到本章节

#### 4.1 界面原型

**内容要求**：
- 提供功能相关界面的原型图（可以是手绘、设计稿或成品截图）
- 使用markdown图片语法嵌入原型图：`![界面名称](图片路径)`
- 每个界面原型图需要简要说明其用途和显示时机

**示例结构**：

```markdown
#### 主界面原型
![主界面](./prototypes/main_ui.png)
- **显示时机**：玩家点击功能入口后显示
- **主要元素**：功能标题、资源显示、任务列表、操作按钮

#### 奖励弹窗原型
![奖励弹窗](./prototypes/reward_popup.png)
- **显示时机**：完成任务领取奖励时弹出
- **主要元素**：奖励内容、确认按钮、分享按钮
```

#### 4.2 UE交互说明

**内容要求**：
- 描述用户与界面的交互方式和反馈
- 说明界面跳转逻辑和动画效果
- 明确各种状态下的界面表现

**推荐格式**：

| 交互操作 | 触发条件 | 界面反馈 | 跳转/变化 |
|---------|---------|---------|----------|
| 点击功能入口按钮 | 满足开启条件 | 按钮高亮，播放点击音效 | 打开主界面 |
| 点击任务"提交"按钮 | 完成任务目标 | 按钮高亮，播放成功音效 | 弹出奖励确认窗口 |
| 点击"升级"按钮 | 资源充足 | 播放升级动画，更新数值显示 | 留在当前界面，刷新显示 |
| 点击"关闭"按钮 | 无 | 播放关闭音效 | 关闭当前界面 |

**界面状态说明示例**：

```markdown
**主界面状态**：

1. **未开启状态**
   - 功能入口显示灰色锁定图标
   - 鼠标悬停显示提示文本："主堡等级达到5级后开启"

2. **可使用状态**
   - 功能入口显示正常彩色图标
   - 右上角显示可领取奖励数量（如有）
   - 点击后进入主界面

3. **冷却中状态**
   - 功能入口显示冷却倒计时
   - 鼠标悬停显示提示文本："XX:XX后可再次使用"
```

#### 4.3 动画效果说明（可选）

**内容要求**：
- 描述关键操作的动画效果
- 说明动画时长和表现形式
- 明确动画是否可跳过

**示例**：

| 动画类型 | 触发时机 | 动画描述 | 时长 | 是否可跳过 |
|---------|---------|---------|------|-----------|
| 开启动画 | 首次达到开启条件 | 功能入口从暗到亮，闪烁3次 | 2秒 | 否，首次强制观看 |
| 升级动画 | 建筑升级完成 | 建筑发光，粒子特效上升 | 1.5秒 | 是，点击任意位置跳过 |
| 奖励飞入动画 | 领取奖励时 | 奖励图标从屏幕中央飞向对应资源位置 | 1秒 | 是，批量领取时可跳过 |

**填写建议**：
- 界面原型和UE说明可以独立添加，不需要同时完成
- 如果功能较简单，可以仅提供主界面原型即可
- 对于复杂功能，建议提供完整的界面流程图，展示界面之间的跳转关系
- 使用截图、手绘草图或专业设计稿都可以，重点是清晰表达交互逻辑

---

### 五、策划需求

**目的**：明确功能实现所需的数值配置和系统支持。

#### 5.1 数值需求
- 列出所有需要配置的数值参数
- **必须明确区分硬编码参数和可配置参数** ⚠️
- 如果数值较多，使用表格整理

**硬编码参数示例**（固定值，不需要在配置表中存储）：
- 免费加速时间阈值：≤5分钟
- VIP建造队列解锁等级：VIP3  
- 离线产出最大累积时长：48小时

**可配置参数示例**（需要在配置表中设计字段）：

| 参数名称 | 取值 | 说明 | 配置表字段 |
|----------|------|------|------------|
| 每日参与次数 | 3 | 基础次数，VIP可增加 | daily_count |
| 单次消耗体力 | 10 | 每次参与消耗 | cost_energy |
| 奖励金币基础值 | 1000 | 基础奖励，随等级浮动 | reward_base_gold |
| 奖励浮动系数 | 1.2 | 每提升1级，奖励×1.2 | reward_multiplier |

**参数标注规范**：
- 在规则说明中提到参数时，必须注明是否可配置
  - 硬编码：直接写明确数值，如"剩余时间≤5分钟可免费完成"
  - 可配置：注明"见配置表"或在括号中标注字段名，如"建造时长（build_time字段）"

#### 5.2 系统需求
- 说明需要其他系统提供的支持
- 列出依赖的系统模块和接口
- 示例：
  > - 需要背包系统支持道具存储和使用
  > - 需要任务系统提供任务进度追踪接口
  > - 需要邮件系统支持离线奖励发送
  > - 需要红点系统支持自定义红点逻辑

#### 5.3 配置表需求

**目的**：定义功能所需的配置表结构，明确字段设计和数据组织方式。

⚠️ **配置表复用原则**：
- 优先复用已有配置表（通过【增加数据】或【增加字段】方式）
- 只有在没有合适的已有表时，才能创建【新建】表
- 必须在每个表前明确标注操作类型：【增加数据】、【增加字段】或【新建】
- 必须说明为什么选择该操作类型

⚠️ **配置表字段设计原则** - **以Excel为主**：
- **禁止使用JSON或复杂嵌套结构**：配置表必须以Excel编辑为主，所有字段必须是扁平化的基础类型
- **基础类型**：int、string、float等Excel直接支持的类型
- **处理多值字段**：使用逗号分隔的字符串（如："1,2,3,4"）
- **处理多属性字段**：展开为多组字段（如：attribute_1_id, attribute_1_value, attribute_2_id, attribute_2_value）
- **错误示例**：`unlock_rewards | json | {"dialogue": [1,2], "items": [10,20]}`
- **正确示例**：`unlock_dialogue_ids | string | "1,2" 和 unlock_item_ids | string | "10,20"`

**操作类型和标注方式**：

**【增加数据】**在已有表 xxx_config 中增加以下数据行：

| 字段名 | 数据值示例 |
|--------|------------|
| item_id | 10001 |
| item_name | 新道具 |
| item_count | 5 |

**【增加字段】**在已有表 xxx_config 中增加以下字段：

| 字段名 | 类型 | 说明 | 对应规则参数 |
|--------|------|------|-------------|
| new_field | int | 新增字段说明 | 规则3.x中的"xxx参数" |

**【新建】**新建表：xxx_config

**说明为什么需要新建：**现有的 aaa_config 和 bbb_config 表都无法满足该功能的配置需求，因为...

| 字段名 | 类型 | 说明 | 对应规则参数 |
|--------|------|------|-------------|
| config_id | int | 配置ID，主键 | - |
| config_name | string | 配置名称 | - |

**基础要求**：
- **配置表字段必须覆盖规则中提到的所有可配置参数**
- 每个字段必须注明对应的规则章节，确保一致性
- 字段命名遵循项目规范（参考步骤0的项目文档分析结果）
- 复杂参数可使用json类型存储，但必须在说明中描述json结构
- **配置表字段必须覆盖规则中提到的所有可配置参数** ⚠️
- 示例：

**新建表：activity_config**

| 字段名 | 类型 | 说明 | 对应规则参数 |
|--------|------|------|-------------|
| activity_id | int | 活动ID，主键 | - |
| activity_name | string | 活动名称 | - |
| start_time | datetime | 开始时间 | 规则3.2中的"活动开始时间" |
| end_time | datetime | 结束时间 | 规则3.5中的"活动结束时间" |
| open_condition | json | 开启条件配置 | 规则3.2中的"开启条件" |
| reward_config | json | 奖励配置 | 规则3.5中的"奖励发放" |

**配置表设计要求**：
- 每个字段必须注明对应的规则章节，确保一致性
- 字段命名遵循项目规范（参考步骤0的项目文档分析结果）
- 复杂参数可使用json类型存储，但必须在说明中描述json结构

---

## 文档编写注意事项

### 格式规范

1. **标题层级**
   - 文档标题：使用Heading标题样式
   - 一级章节（一、二、三、四）：Heading 1
   - 二级章节（1.1、2.1等）：Heading 2
   - 三级章节（细分内容）：Heading 3

2. **表格使用**
   - 状态机、条件、规则等结构化内容优先使用表格
   - 表格必须包含清晰的表头
   - 单元格内容简洁明了

3. **列表使用**
   - 使用项目符号或编号列表
   - 层级清晰，缩进规范

### 内容要求

1. **准确性**：所有规则和数值必须明确，避免模糊表述
2. **完整性**：覆盖所有功能场景，包括正常流程和异常情况
3. **清晰性**：逻辑清晰，易于理解和实现
4. **可执行性**：开发人员能根据文档直接实现功能
5. **纯文本描述** ⚠️ **严格要求**：
   - **绝对禁止使用代码或伪代码**来描述客户端和服务器规则
   - 不允许出现if/else/for/while等编程语句
   - 不允许出现函数调用形式，如"function()”
   - 必须使用自然语言、表格、列表来表述规则
   - 数值计算使用数学公式格式，不使用代码语法

### 根据功能类型调整

不同类型的功能可能需要调整章节：

- **系统玩法类**（如神石、活动）：保留所有章节，重点是规则说明
- **建筑功能类**：增加"建筑升级规则"、"加速规则"等专属章节
- **战斗功能类**：增加"战斗流程"、"伤害计算"等专属章节
- **简单功能**：可以省略"功能状态机"、"红点提示规则"等可选章节

---

## 示例参考

在`examples`文件夹中提供了不同类型功能的文档示例：

- **example_activity.md** - 活动功能示例（活动中心）
- **example_building.md** - 建筑功能示例（城堡建设）
- **example_system.md** - 系统玩法示例（神石玩法）

建议在编写文档前先查看相关示例，了解各章节的填写方式和深度。

---

## 生成脚本说明

`scripts/generate_doc.py`提供了快速生成文档框架的功能：

**基础用法**：
```bash
python generate_doc.py --name "功能名称" --type "system"
```

**参数说明**：
- `--name`：功能名称（必填）
- `--type`：功能类型，可选值：system/building/activity/other（必填）
- `--output`：输出路径（可选，默认为当前目录）

**脚本功能**：
- 自动创建包含标准章节结构的Word文档
- 根据功能类型调整章节（例如建筑类型会添加建筑特定规则）
- 预填充章节标题和基础表格模板

生成文档后，根据实际需求填充内容即可。

---

## 最后提醒

✅ **必须包含的章节**：设计目的、功能概述、规则说明、策划需求

⚠️ **文档聚焦于策划设计**，不包含UI原型、美术资源、竞品分析等内容

📝 **文档是开发的依据**，必须详尽准确，所有规则都要明确说明

🔄 **持续更新**，功能调整时及时更新文档，保持文档与实现一致

🚫 **严禁策划思考** ⚠️ **关键要求**：
   - **开发文档只能包含客观的功能说明和规则描述**
   - **绝对禁止**包含策划主观思考、设计意图、期望效果等内容
   
   **适用范围**：
   - ✅ 该规则**仅适用于"规则说明"和"策划需求"章节**
   - ❌ **不适用于**"设计目的"和"期望体验"章节
   - 说明："设计目的"和"期望体验"章节**可以**包含主观意图和期望效果
   
   **示例对比**：
   - **错误示例**："简单易懂的规则"、"丰富的玩法"、"控制节奏"、"鼓励留存"、"增强体验"
   - **正确示例**："两个物件合成为一个"、"包含4个品类"、"消耗1点体力"、"每5分钟恢复1点"
   - **判断标准**：如果某个描述包含"为了..."、"通过...达到..."、评价性形容词，则属于策划思考，需要删除
   - **具体对比**：
     | 策划思考（禁止） | 客观描述（正确） |
     |---------------|----------------|
     | 简单易懂的合成规则 | 两个相同品类、相同等级的物件合成为更高一级物件 |
     | 提供丰富的合成目标 | 包含4个物件品类，每个品类10个等级 |
     | 通过体力控制节奏，鼓励长期留存 | 每次点击作坊消耗1点体力，体力每5分钟恢复1点 |
     | 增强玩家的策略性体验 | 玩家可选择升级不同的作坊，优先合成不同的物件 |

